// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
 * TrustVaultPlusV4
 * - Refactored & feature-enhanced version of TrustVaultPlusV3
 * - Uses OpenZeppelin patterns: AccessControl, Ownable, Pausable, Counters
 * - Adds batch operations, issuer pagination, extra safety checks, and utility views
 *
 * NOTE: install OpenZeppelin contracts in your project:
 *   npm install @openzeppelin/contracts
 */

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract TrustVaultPlusV4 is AccessControl, Ownable, Pausable {
    using Counters for Counters.Counter;

    /// @notice Role granted to trusted issuers
    bytes32 public constant ISSUER_ROLE = keccak256("ISSUER_ROLE");

    /// @notice Compact credential state
    enum CredentialState { Issued, Verified, Revoked }

    /// @notice Stored credential
    struct Credential {
        uint256 id;            // credential id (non-zero)
        address subject;       // subject address
        address issuer;        // issuer address
        string title;          // title
        string description;    // description
        uint64 timestamp;      // issuance timestamp
        CredentialState state; // state
    }

    /// @notice Minimal identity record
    struct Identity {
        string name;
        string email;
        bool isRegistered;
    }

    // Storage
    Counters.Counter private _credentialIdCounter;
    mapping(address => Identity) private _identities;
    mapping(bytes32 => address) private _emailHashToAddress; // keccak256(email) -> addr

    mapping(uint256 => Credential) private _credentials;
    mapping(address => uint256[]) private _userCredentialIds;
    mapping(address => uint256[]) private _issuerCredentialIds;

    // Events
    event IdentityRegistered(address indexed user, string name, string email);
    event IdentityUpdated(address indexed user, string name, string email);
    event IdentityDeregistered(address indexed user);

    event IssuerGranted(address indexed issuer);
    event IssuerRevoked(address indexed issuer);

    event CredentialIssued(uint256 indexed credentialId, address indexed subject, address indexed issuer, string title);
    event CredentialVerified(uint256 indexed credentialId, address indexed verifier);
    event CredentialRevoked(uint256 indexed credentialId, address indexed revokedBy);
    event CredentialUpdated(uint256 indexed credentialId, string newTitle, string newDescription, address indexed updatedBy);

    // Constructor
    constructor() {
        // deployer -> default admin
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        // deployer -> issuer by default (can be revoked)
        _setupRole(ISSUER_ROLE, _msgSender());
        transferOwnership(_msgSender());

        // Start IDs at 1: increment once so current() == 1 and returned id = 1 on first _nextId()
        _credentialIdCounter.increment();
    }

    // ----------------------------
    // Modifiers
    // ----------------------------
    modifier onlyRegistered(address user) {
        require(_identities[user].isRegistered, "User not registered");
        _;
    }

    modifier credentialExists(uint256 credentialId) {
        require(credentialId != 0 && _credentials[credentialId].id != 0, "Credential not found");
        _;
    }

    modifier onlyIssuer() {
        require(hasRole(ISSUER_ROLE, _msgSender()), "Caller is not an issuer");
        _;
    }

    // ----------------------------
    // Identity management
    // ----------------------------

    /// @notice Register caller identity with name and email (email uniqueness enforced via hash)
    function registerIdentity(string calldata name, string calldata email) external whenNotPaused {
        require(!_identities[_msgSender()].isRegistered, "Already registered");
        require(bytes(name).length > 0 && bytes(email).length > 0, "Invalid name/email");

        bytes32 h = keccak256(bytes(email));
        require(_emailHashToAddress[h] == address(0), "Email already used");

        _identities[_msgSender()] = Identity({name: name, email: email, isRegistered: true});
        _emailHashToAddress[h] = _msgSender();

        emit IdentityRegistered(_msgSender(), name, email);
    }

    /// @notice Update caller identity. If email changes, rebind hash map safely.
    function updateIdentity(string calldata name, string calldata email) external onlyRegistered(_msgSender()) whenNotPaused {
        require(bytes(name).length > 0 && bytes(email).length > 0, "Invalid name/email");

        string memory oldEmail = _identities[_msgSender()].email;
        if (keccak256(bytes(oldEmail)) != keccak256(bytes(email))) {
            bytes32 newHash = keccak256(bytes(email));
            require(_emailHashToAddress[newHash] == address(0), "Email already used");

            // clear old map if set
            if (bytes(oldEmail).length > 0) {
                _emailHashToAddress[keccak256(bytes(oldEmail))] = address(0);
            }
            _emailHashToAddress[newHash] = _msgSender();
            _identities[_msgSender()].email = email;
        }
        _identities[_msgSender()].name = name;

        emit IdentityUpdated(_msgSender(), name, email);
    }

    /// @notice Deregister caller identity and clear email binding
    function deregisterIdentity() external onlyRegistered(_msgSender()) whenNotPaused {
        bytes32 h = keccak256(bytes(_identities[_msgSender()].email));
        if (_emailHashToAddress[h] != address(0)) {
            _emailHashToAddress[h] = address(0);
        }
        delete _identities[_msgSender()];
        emit IdentityDeregistered(_msgSender());
    }

    /// @notice View identity for an address
    function getIdentity(address user) external view returns (Identity memory) {
        return _identities[user];
    }

    /// @notice Lookup an address by email (returns address(0) if not bound)
    function getIdentityByEmail(string calldata email) external view returns (address) {
        if (bytes(email).length == 0) return address(0);
        return _emailHashToAddress[keccak256(bytes(email))];
    }

    /// @notice Check whether an email is already bound
    function isEmailBound(string calldata email) external view returns (bool) {
        if (bytes(email).length == 0) return false;
        return _emailHashToAddress[keccak256(bytes(email))] != address(0);
    }

    // ----------------------------
    // Issuer management
    // ----------------------------

    /// @notice Owner grants issuer privileges
    function grantIssuer(address account) external onlyOwner whenNotPaused {
        require(account != address(0), "Zero address");
        grantRole(ISSUER_ROLE, account);
        emit IssuerGranted(account);
    }

    /// @notice Owner revokes issuer privileges
    function revokeIssuer(address account) external onlyOwner whenNotPaused {
        require(account != address(0), "Zero address");
        revokeRole(ISSUER_ROLE, account);
        emit IssuerRevoked(account);
    }

    /// @notice Check if account is an issuer
    function isIssuer(address account) external view returns (bool) {
        return hasRole(ISSUER_ROLE, account);
    }

    /// @notice Allows an issuer to renounce their own issuer role
    function renounceIssuerRole() external whenNotPaused {
        renounceRole(ISSUER_ROLE, _msgSender());
        emit IssuerRevoked(_msgSender());
    }

    // ----------------------------
    // Pause / Unpause (Owner)
    // ----------------------------
    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // ----------------------------
    // Credential lifecycle
    // ----------------------------
    function _nextId() internal returns (uint256) {
        uint256 id = _credentialIdCounter.current();
        _credentialIdCounter.increment();
        return id;
    }

    /// @notice Issue a single credential. Caller must be an issuer and subject must be registered.
    function issueCredential(address subject, string calldata title, string calldata description)
        public whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        require(subject != address(0) && bytes(title).length > 0, "Invalid input");

        uint256 cid = _nextId();
        _credentials[cid] = Credential({
            id: cid,
            subject: subject,
            issuer: _msgSender(),
            title: title,
            description: description,
            timestamp: uint64(block.timestamp),
            state: CredentialState.Issued
        });

        _userCredentialIds[subject].push(cid);
        _issuerCredentialIds[_msgSender()].push(cid);

        emit CredentialIssued(cid, subject, _msgSender(), title);
        return cid;
    }

    /// @notice Issue multiple credentials in a single transaction
    function batchIssueCredentials(address[] calldata subjects, string[] calldata titles, string[] calldata descriptions)
        external whenNotPaused onlyIssuer returns (uint256[] memory)
    {
        require(subjects.length > 0, "Empty subjects");
        uint256 n = subjects.length;
        require(titles.length == n && descriptions.length == n, "Array length mismatch");

        uint256[] memory issuedIds = new uint256[](n);
        for (uint256 i = 0; i < n; ++i) {
            // will revert if subject isn't registered or invalid input
            issuedIds[i] = issueCredential(subjects[i], titles[i], descriptions[i]);
        }
        return issuedIds;
    }

    /// @notice Issue and immediately verify the issued credential
    function issueAndVerify(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        uint256 cid = issueCredential(subject, title, description);
        _credentials[cid].state = CredentialState.Verified;
        emit CredentialVerified(cid, _msgSender());
        return cid;
    }

    /// @notice Verify a credential (only issuers). Only valid when credential in Issued state.
    function verifyCredential(uint256 credentialId) external whenNotPaused onlyIssuer credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        require(cred.state == CredentialState.Issued, "Not in issued state");
        cred.state = CredentialState.Verified;
        emit CredentialVerified(credentialId, _msgSender());
    }

    /// @notice Batch verify credentials (issuer must be caller for each)
    function batchVerify(uint256[] calldata credentialIds) external whenNotPaused onlyIssuer {
        require(credentialIds.length > 0, "Empty list");
        for (uint256 i = 0; i < credentialIds.length; ++i) {
            uint256 id = credentialIds[i];
            if (id == 0 || _credentials[id].id == 0) continue;
            Credential storage cred = _credentials[id];
            if (cred.state != CredentialState.Issued) continue;
            // optionally allow other issuers to verify (business logic choice)
            cred.state = CredentialState.Verified;
            emit CredentialVerified(id, _msgSender());
        }
    }

    /// @notice Revoke a credential. Only issuer of credential or owner can revoke.
    function revokeCredential(uint256 credentialId) external whenNotPaused credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        require(cred.state != CredentialState.Revoked, "Already revoked");
        require(_msgSender() == cred.issuer || owner() == _msgSender(), "Not authorized");
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    /// @notice Batch revoke with per-credential authorization checks (issuer or owner)
    function batchRevoke(uint256[] calldata ids) external whenNotPaused {
        require(ids.length > 0, "Empty list");
        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (id == 0 || _credentials[id].id == 0) continue; // skip invalid
            Credential storage cred = _credentials[id];
            if (cred.state == CredentialState.Revoked) continue;
            if (_msgSender() != cred.issuer && _msgSender() != owner()) continue; // skip unauthorized
            cred.state = CredentialState.Revoked;
            emit CredentialRevoked(id, _msgSender());
        }
    }

    /// @notice Update credential title/description (only issuer, not revoked)
    function updateCredentialMetadata(uint256 credentialId, string calldata newTitle, string calldata newDescription)
        external whenNotPaused credentialExists(credentialId)
    {
        require(bytes(newTitle).length > 0, "Empty title");
        Credential storage cred = _credentials[credentialId];
        require(_msgSender() == cred.issuer, "Only issuer can update");
        require(cred.state != CredentialState.Revoked, "Cannot update revoked credential");

        cred.title = newTitle;
        cred.description = newDescription;
        emit CredentialUpdated(credentialId, newTitle, newDescription, _msgSender());
    }

    // ----------------------------
    // Views / Getters
    // ----------------------------
    function getCredential(uint256 credentialId) external view credentialExists(credentialId) returns (Credential memory) {
        return _credentials[credentialId];
    }

    /// @notice Total issued credentials (id counter - 1)
    function totalCredentials() external view returns (uint256) {
        // next - 1
        return _credentialIdCounter.current() - 1;
    }

    function getUserCredentials(address user) external view returns (uint256[] memory) {
        return _userCredentialIds[user];
    }

    function getIssuerCredentials(address issuer) external view returns (uint256[] memory) {
        return _issuerCredentialIds[issuer];
    }

    /// @notice Pagination helper to avoid OOG on large user lists
    function getUserCredentialsPaged(address user, uint256 cursor, uint256 pageSize)
        external view returns (uint256[] memory, uint256)
    {
        uint256 length = _userCredentialIds[user].length;
        if (cursor >= length) return (new uint256, cursor);

        uint256 to = cursor + pageSize;
        if (to > length) to = length;
        uint256[] memory page = new uint256[](to - cursor);
        for (uint256 i = cursor; i < to; ++i) {
            page[i - cursor] = _userCredentialIds[user][i];
        }
        return (page, to);
    }

    /// @notice Pagination helper for issuer credential list
    function getIssuerCredentialsPaged(address issuer, uint256 cursor, uint256 pageSize)
        external view returns (uint256[] memory, uint256)
    {
        uint256 length = _issuerCredentialIds[issuer].length;
        if (cursor >= length) return (new uint256, cursor);

        uint256 to = cursor + pageSize;
        if (to > length) to = length;
        uint256[] memory page = new uint256[](to - cursor);
        for (uint256 i = cursor; i < to; ++i) {
            page[i - cursor] = _issuerCredentialIds[issuer][i];
        }
        return (page, to);
    }

    // ----------------------------
    // Admin utilities
    // ----------------------------
    /// @notice Owner can perform a forced revoke (emergency)
    function ownerForceRevoke(uint256 credentialId) external onlyOwner credentialExists(credentialId) whenNotPaused {
        Credential storage cred = _credentials[credentialId];
        if (cred.state == CredentialState.Revoked) return;
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    /// @notice Allow owner to recover mistaken email bindings (careful!)
    function adminClearEmailBinding(string calldata email) external onlyOwner whenNotPaused {
        bytes32 h = keccak256(bytes(email));
        _emailHashToAddress[h] = address(0);
    }

    /// @notice Owner may renounce DEFAULT_ADMIN_ROLE (irreversible)
    function renounceAllRoles() external onlyOwner whenNotPaused {
        revokeRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    // ----------------------------
    // Optional helpers (convenience)
    // ----------------------------

    /// @notice Issue only if subject doesn't already have an identical title issued by same issuer (soft uniqueness)
    /// This is a convenience — in many systems duplicate credentials are acceptable; remove if not desired.
    function issueIfNotExists(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        // naive duplicate check: scan issuerCredentialIds for same (subject + title)
        uint256[] storage issuerList = _issuerCredentialIds[_msgSender()];
        for (uint256 i = 0; i < issuerList.length; ++i) {
            Credential storage c = _credentials[issuerList[i]];
            if (c.subject == subject && keccak256(bytes(c.title)) == keccak256(bytes(title)) && c.state != CredentialState.Revoked) {
                // existing active credential found; return existing id
                return c.id;
            }
        }
        return issueCredential(subject, title, description);
    }
}

