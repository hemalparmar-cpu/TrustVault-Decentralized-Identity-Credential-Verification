// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
 * TrustVaultPlusV3
 * - Refactored, hardened and feature-enhanced version of the supplied TrustVaultPlusV2
 * - Uses OpenZeppelin patterns (AccessControl, Ownable, Pausable, Counters)
 * - Role-based issuer management, batch operations, safer email handling, and pagination helpers
 *
 * Notes:
 * - This file imports OpenZeppelin contracts; install OpenZeppelin contracts in your project.
 *   e.g. `npm install @openzeppelin/contracts`
 */

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract TrustVaultPlusV3 is AccessControl, Ownable, Pausable {
    using Counters for Counters.Counter;

    // Roles
    bytes32 public constant ISSUER_ROLE = keccak256("ISSUER_ROLE");

    enum CredentialState { Issued, Verified, Revoked }

    struct Credential {
        uint256 id;            // starts at 1
        address subject;
        address issuer;       // min: 20 bytes
        string title;         // dynamic
        string description;   // dynamic
        uint64 timestamp;     // packed as uint64 to save gas
        CredentialState state;
    }

    struct Identity {
        string name;
        string email;
        bool isRegistered;
    }

    // Storage
    Counters.Counter private _credentialIdCounter;
    mapping(address => Identity) private _identities;
    mapping(bytes32 => address) private _emailHashToAddress; // keccak256(email) -> addr

    mapping(uint256 => Credential) private _credentials;
    mapping(address => uint256[]) private _userCredentialIds;
    mapping(address => uint256[]) private _issuerCredentialIds;

    // Events
    event IdentityRegistered(address indexed user, string name, string email);
    event IdentityUpdated(address indexed user, string name, string email);
    event IdentityDeregistered(address indexed user);

    event IssuerGranted(address indexed issuer);
    event IssuerRevoked(address indexed issuer);

    event CredentialIssued(uint256 indexed credentialId, address indexed subject, address indexed issuer, string title);
    event CredentialVerified(uint256 indexed credentialId, address indexed verifier);
    event CredentialRevoked(uint256 indexed credentialId, address indexed revokedBy);
    event CredentialUpdated(uint256 indexed credentialId, string newTitle, string newDescription, address indexed updatedBy);

    // Constructor
    constructor() {
        // Grant deployer default admin role for AccessControl
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        // Give the deployer issuer role by default
        _setupRole(ISSUER_ROLE, _msgSender());
        transferOwnership(_msgSender());
        _credentialIdCounter.increment(); // start ids at 1 (reserve 0 as non-existent)
    }

    // ----------------------------
    // Modifiers
    // ----------------------------
    modifier onlyRegistered(address user) {
        require(_identities[user].isRegistered, "User not registered");
        _;
    }

    modifier credentialExists(uint256 credentialId) {
        require(credentialId != 0 && _credentials[credentialId].id != 0, "Credential not found");
        _;
    }

    modifier onlyIssuer() {
        require(hasRole(ISSUER_ROLE, _msgSender()), "Caller is not an issuer");
        _;
    }

    // ----------------------------
    // Identity management
    // ----------------------------
    function registerIdentity(string calldata name, string calldata email) external whenNotPaused {
        require(!_identities[_msgSender()].isRegistered, "Already registered");
        require(bytes(name).length > 0 && bytes(email).length > 0, "Invalid name/email");

        bytes32 h = keccak256(bytes(email));
        require(_emailHashToAddress[h] == address(0), "Email already used");

        _identities[_msgSender()] = Identity({name: name, email: email, isRegistered: true});
        _emailHashToAddress[h] = _msgSender();

        emit IdentityRegistered(_msgSender(), name, email);
    }

    function updateIdentity(string calldata name, string calldata email) external onlyRegistered(_msgSender()) whenNotPaused {
        require(bytes(name).length > 0 && bytes(email).length > 0, "Invalid name/email");

        string memory oldEmail = _identities[_msgSender()].email;
        if (keccak256(bytes(oldEmail)) != keccak256(bytes(email))) {
            bytes32 newHash = keccak256(bytes(email));
            require(_emailHashToAddress[newHash] == address(0), "Email already used");

            // clear old map
            if (bytes(oldEmail).length > 0) {
                _emailHashToAddress[keccak256(bytes(oldEmail))] = address(0);
            }
            _emailHashToAddress[newHash] = _msgSender();
            _identities[_msgSender()].email = email;
        }
        _identities[_msgSender()].name = name;

        emit IdentityUpdated(_msgSender(), name, email);
    }

    function deregisterIdentity() external onlyRegistered(_msgSender()) whenNotPaused {
        bytes32 h = keccak256(bytes(_identities[_msgSender()].email));
        if (_emailHashToAddress[h] != address(0)) {
            _emailHashToAddress[h] = address(0);
        }
        delete _identities[_msgSender()];
        emit IdentityDeregistered(_msgSender());
    }

    function getIdentity(address user) external view returns (Identity memory) {
        return _identities[user];
    }

    function getIdentityByEmail(string calldata email) external view returns (address) {
        if (bytes(email).length == 0) return address(0);
        return _emailHashToAddress[keccak256(bytes(email))];
    }

    // ----------------------------
    // Issuer management (access controlled)
    // ----------------------------
    function grantIssuer(address account) external onlyOwner whenNotPaused {
        require(account != address(0), "Zero address");
        grantRole(ISSUER_ROLE, account);
        emit IssuerGranted(account);
    }

    function revokeIssuer(address account) external onlyOwner whenNotPaused {
        require(account != address(0), "Zero address");
        revokeRole(ISSUER_ROLE, account);
        emit IssuerRevoked(account);
    }

    function isIssuer(address account) external view returns (bool) {
        return hasRole(ISSUER_ROLE, account);
    }

    // ----------------------------
    // Pause / Unpause
    // ----------------------------
    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // ----------------------------
    // Credential lifecycle
    // ----------------------------
    function _nextId() internal returns (uint256) {
        uint256 id = _credentialIdCounter.current();
        _credentialIdCounter.increment();
        return id;
    }

    function issueCredential(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        require(subject != address(0) && bytes(title).length > 0, "Invalid input");

        uint256 cid = _nextId();
        _credentials[cid] = Credential({
            id: cid,
            subject: subject,
            issuer: _msgSender(),
            title: title,
            description: description,
            timestamp: uint64(block.timestamp),
            state: CredentialState.Issued
        });

        _userCredentialIds[subject].push(cid);
        _issuerCredentialIds[_msgSender()].push(cid);

        emit CredentialIssued(cid, subject, _msgSender(), title);
        return cid;
    }

    function issueAndVerify(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        uint256 cid = issueCredential(subject, title, description);
        _credentials[cid].state = CredentialState.Verified;
        emit CredentialVerified(cid, _msgSender());
        return cid;
    }

    function verifyCredential(uint256 credentialId) external whenNotPaused onlyIssuer credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        require(cred.state == CredentialState.Issued, "Not in issued state");
        cred.state = CredentialState.Verified;
        emit CredentialVerified(credentialId, _msgSender());
    }

    function revokeCredential(uint256 credentialId) external whenNotPaused credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        require(cred.state != CredentialState.Revoked, "Already revoked");
        require(_msgSender() == cred.issuer || owner() == _msgSender(), "Not authorized");
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    function batchRevoke(uint256[] calldata ids) external whenNotPaused {
        require(ids.length > 0, "Empty list");
        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (id == 0 || _credentials[id].id == 0) continue; // skip invalid
            Credential storage cred = _credentials[id];
            if (cred.state == CredentialState.Revoked) continue;
            if (_msgSender() != cred.issuer && _msgSender() != owner()) continue; // skip unauthorized
            cred.state = CredentialState.Revoked;
            emit CredentialRevoked(id, _msgSender());
        }
    }

    function updateCredentialMetadata(uint256 credentialId, string calldata newTitle, string calldata newDescription)
        external whenNotPaused credentialExists(credentialId)
    {
        require(bytes(newTitle).length > 0, "Empty title");
        Credential storage cred = _credentials[credentialId];
        require(_msgSender() == cred.issuer, "Only issuer can update");
        require(cred.state != CredentialState.Revoked, "Cannot update revoked credential");

        cred.title = newTitle;
        cred.description = newDescription;
        emit CredentialUpdated(credentialId, newTitle, newDescription, _msgSender());
    }

    // ----------------------------
    // Views / Getters
    // ----------------------------
    function getCredential(uint256 credentialId) external view credentialExists(credentialId) returns (Credential memory) {
        return _credentials[credentialId];
    }

    function totalCredentials() external view returns (uint256) {
        // next - 1
        return _credentialIdCounter.current() - 1;
    }

    function getUserCredentials(address user) external view returns (uint256[] memory) {
        return _userCredentialIds[user];
    }

    function getIssuerCredentials(address issuer) external view returns (uint256[] memory) {
        return _issuerCredentialIds[issuer];
    }

    // Pagination helper to avoid out-of-gas on large arrays
    function getUserCredentialsPaged(address user, uint256 cursor, uint256 pageSize)
        external view returns (uint256[] memory, uint256)
    {
        uint256 length = _userCredentialIds[user].length;
        if (cursor >= length) return (new uint256[](0), cursor);

        uint256 to = cursor + pageSize;
        if (to > length) to = length;
        uint256[] memory page = new uint256[](to - cursor);
        for (uint256 i = cursor; i < to; ++i) {
            page[i - cursor] = _userCredentialIds[user][i];
        }
        return (page, to);
    }

    // ----------------------------
    // Admin utilities
    // ----------------------------
    // Owner can perform a forced revoke (emergency)
    function ownerForceRevoke(uint256 credentialId) external onlyOwner credentialExists(credentialId) whenNotPaused {
        Credential storage cred = _credentials[credentialId];
        if (cred.state == CredentialState.Revoked) return;
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    // Allow owner to recover mistaken email bindings
    function adminClearEmailBinding(string calldata email) external onlyOwner whenNotPaused {
        bytes32 h = keccak256(bytes(email));
        _emailHashToAddress[h] = address(0);
    }

    // ----------------------------
    // Hooks
    // ----------------------------
    // Allow renouncing admin roles via AccessControl
    function renounceAllRoles() external onlyOwner whenNotPaused {
        // owner chooses to renounce DEFAULT_ADMIN_ROLE; this is irreversible for the account
        revokeRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }
}

