// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title TrustVaultPlusV5 (refined)
 * @notice Gas, safety, and ergonomics focused refinement of the supplied TrustVaultPlusV5.
 * - Introduces custom errors to reduce revert-string gas costs
 * - Uses `external` where appropriate and `unchecked` in safe loops
 * - Consolidates common patterns and reduces duplicate storage reads
 * - Adds `supportsInterface` override required by multiple inheritance
 * - Small API ergonomics: clearer names, immutability where useful
 *
 * NOTE: install OpenZeppelin contracts:
 *   npm i @openzeppelin/contracts
 */

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

contract TrustVaultPlusV5 is AccessControl, Ownable, Pausable, ReentrancyGuard {
    using Counters for Counters.Counter;
    using EnumerableSet for EnumerableSet.AddressSet;

    // --- Constants / Types
    bytes32 public constant ISSUER_ROLE = keccak256("ISSUER_ROLE");

    enum CredentialState { Issued, Verified, Revoked }

    struct Credential {
        uint256 id;
        address subject;
        address issuer;
        string title;
        string description; // free text or IPFS hash (recommended)
        uint64 timestamp;
        CredentialState state;
    }

    struct Identity {
        string name;
        string email;
        bool isRegistered;
    }

    // --- Custom errors (cheaper than revert strings)
    error ZeroAddress();
    error AlreadyRegistered();
    error NotRegistered();
    error InvalidInput();
    error EmailInUse();
    error NotIssuer();
    error CredentialNotFound();
    error NotAuthorized();
    error EmptyArray();
    error EmptyTitle();

    // --- Storage
    Counters.Counter private _credentialIdCounter;
    mapping(address => Identity) private _identities;
    mapping(bytes32 => address) private _emailHashToAddress;

    mapping(uint256 => Credential) private _credentials;
    mapping(address => uint256[]) private _userCredentialIds;
    mapping(address => uint256[]) private _issuerCredentialIds;

    EnumerableSet.AddressSet private _issuers;

    // --- Events
    event IdentityRegistered(address indexed user, string name, string email);
    event IdentityUpdated(address indexed user, string name, string email);
    event IdentityDeregistered(address indexed user);

    event IssuerGranted(address indexed issuer);
    event IssuerRevoked(address indexed issuer);

    event CredentialIssued(uint256 indexed credentialId, address indexed subject, address indexed issuer, string title);
    event CredentialBatchIssued(uint256[] ids, address indexed issuer);
    event CredentialVerified(uint256 indexed credentialId, address indexed verifier);
    event CredentialRevoked(uint256 indexed credentialId, address indexed revokedBy);
    event CredentialUpdated(uint256 indexed credentialId, string newTitle, string newDescription, address indexed updatedBy);

    // --- Constructor
    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(ISSUER_ROLE, _msgSender());
        transferOwnership(_msgSender());

        // Start IDs at 1 for clearer truthiness
        _credentialIdCounter.increment();
        _issuers.add(_msgSender());
    }

    // --- Modifiers
    modifier onlyRegistered(address user) {
        if (!_identities[user].isRegistered) revert NotRegistered();
        _;
    }

    modifier credentialExists(uint256 credentialId) {
        if (credentialId == 0 || _credentials[credentialId].id == 0) revert CredentialNotFound();
        _;
    }

    modifier onlyIssuer() {
        if (!hasRole(ISSUER_ROLE, _msgSender())) revert NotIssuer();
        _;
    }

    // --- Identity management

    function registerIdentity(string calldata name, string calldata email) external whenNotPaused {
        if (_identities[_msgSender()].isRegistered) revert AlreadyRegistered();
        if (bytes(name).length == 0 || bytes(email).length == 0) revert InvalidInput();

        bytes32 h = keccak256(bytes(email));
        if (_emailHashToAddress[h] != address(0)) revert EmailInUse();

        // single SSTORE with struct assignment
        _identities[_msgSender()] = Identity({ name: name, email: email, isRegistered: true });
        _emailHashToAddress[h] = _msgSender();

        emit IdentityRegistered(_msgSender(), name, email);
    }

    function updateIdentity(string calldata name, string calldata email) external whenNotPaused onlyRegistered(_msgSender()) {
        if (bytes(name).length == 0 || bytes(email).length == 0) revert InvalidInput();

        Identity storage idRec = _identities[_msgSender()];
        bytes32 oldHash = keccak256(bytes(idRec.email));
        bytes32 newHash = keccak256(bytes(email));

        if (oldHash != newHash) {
            if (_emailHashToAddress[newHash] != address(0)) revert EmailInUse();
            // clear old only if bound to sender
            if (_emailHashToAddress[oldHash] == _msgSender()) {
                _emailHashToAddress[oldHash] = address(0);
            }
            _emailHashToAddress[newHash] = _msgSender();
            idRec.email = email;
        }
        idRec.name = name;

        emit IdentityUpdated(_msgSender(), name, email);
    }

    function deregisterIdentity() external whenNotPaused onlyRegistered(_msgSender()) {
        Identity storage idRec = _identities[_msgSender()];
        bytes32 h = keccak256(bytes(idRec.email));
        if (_emailHashToAddress[h] == _msgSender()) {
            _emailHashToAddress[h] = address(0);
        }
        delete _identities[_msgSender()];
        emit IdentityDeregistered(_msgSender());
    }

    function getIdentity(address user) external view returns (Identity memory) {
        return _identities[user];
    }

    function getIdentityByEmail(string calldata email) external view returns (address) {
        if (bytes(email).length == 0) return address(0);
        return _emailHashToAddress[keccak256(bytes(email))];
    }

    function isEmailBound(string calldata email) external view returns (bool) {
        if (bytes(email).length == 0) return false;
        return _emailHashToAddress[keccak256(bytes(email))] != address(0);
    }

    // --- Issuer management (owner)

    function grantIssuer(address account) external onlyOwner whenNotPaused {
        if (account == address(0)) revert ZeroAddress();
        grantRole(ISSUER_ROLE, account);
        _issuers.add(account);
        emit IssuerGranted(account);
    }

    function revokeIssuer(address account) external onlyOwner whenNotPaused {
        if (account == address(0)) revert ZeroAddress();
        revokeRole(ISSUER_ROLE, account);
        _issuers.remove(account);
        emit IssuerRevoked(account);
    }

    function isIssuer(address account) external view returns (bool) {
        return hasRole(ISSUER_ROLE, account);
    }

    function renounceIssuerRole() external whenNotPaused {
        renounceRole(ISSUER_ROLE, _msgSender());
        _issuers.remove(_msgSender());
        emit IssuerRevoked(_msgSender());
    }

    function listIssuers(uint256 cursor, uint256 pageSize) external view returns (address[] memory page, uint256 newCursor) {
        uint256 total = _issuers.length();
        if (cursor >= total) return (new address[](0), cursor);
        uint256 to = cursor + pageSize;
        if (to > total) to = total;
        page = new address[](to - cursor);
        for (uint256 i = cursor; i < to; ) {
            page[i - cursor] = _issuers.at(i);
            unchecked { ++i; }
        }
        return (page, to);
    }

    // --- Pause / Unpause
    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // --- Credential lifecycle helpers
    function _nextId() internal returns (uint256) {
        uint256 id = _credentialIdCounter.current();
        _credentialIdCounter.increment();
        return id;
    }

    /// @dev Core internal issue function (no modifiers) - minimally checks inputs.
    function _issueCredential(address issuer, address subject, string calldata title, string calldata description)
        internal returns (uint256)
    {
        if (subject == address(0) || bytes(title).length == 0) revert InvalidInput();

        uint256 cid = _nextId();

        _credentials[cid] = Credential({
            id: cid,
            subject: subject,
            issuer: issuer,
            title: title,
            description: description,
            timestamp: uint64(block.timestamp),
            state: CredentialState.Issued
        });

        _userCredentialIds[subject].push(cid);
        _issuerCredentialIds[issuer].push(cid);

        emit CredentialIssued(cid, subject, issuer, title);
        return cid;
    }

    /// @notice Issue a single credential. Subject must be registered.
    function issueCredential(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        return _issueCredential(_msgSender(), subject, title, description);
    }

    /// @notice Batch issue credentials; uses internal _issueCredential to avoid repeating modifiers.
    function batchIssueCredentials(
        address[] calldata subjects,
        string[] calldata titles,
        string[] calldata descriptions
    ) external nonReentrant whenNotPaused onlyIssuer returns (uint256[] memory) {
        uint256 n = subjects.length;
        if (n == 0) revert EmptyArray();
        if (titles.length != n || descriptions.length != n) revert InvalidInput();

        uint256[] memory issuedIds = new uint256[](n);
        for (uint256 i = 0; i < n; ) {
            issuedIds[i] = _issueCredential(_msgSender(), subjects[i], titles[i], descriptions[i]);
            unchecked { ++i; }
        }
        emit CredentialBatchIssued(issuedIds, _msgSender());
        return issuedIds;
    }

    /// @notice Issue and mark verified atomically.
    function issueAndVerify(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        uint256 cid = _issueCredential(_msgSender(), subject, title, description);
        _credentials[cid].state = CredentialState.Verified;
        emit CredentialVerified(cid, _msgSender());
        return cid;
    }

    function verifyCredential(uint256 credentialId) external whenNotPaused onlyIssuer credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        if (cred.state != CredentialState.Issued) revert InvalidInput();
        cred.state = CredentialState.Verified;
        emit CredentialVerified(credentialId, _msgSender());
    }

    function batchVerify(uint256[] calldata credentialIds) external whenNotPaused onlyIssuer {
        uint256 len = credentialIds.length;
        if (len == 0) revert EmptyArray();
        for (uint256 i = 0; i < len; ) {
            uint256 id = credentialIds[i];
            if (id != 0) {
                Credential storage cred = _credentials[id];
                if (cred.id != 0 && cred.state == CredentialState.Issued) {
                    cred.state = CredentialState.Verified;
                    emit CredentialVerified(id, _msgSender());
                }
            }
            unchecked { ++i; }
        }
    }

    // Revoke: only issuer of that credential or owner
    function revokeCredential(uint256 credentialId) external whenNotPaused credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        if (cred.state == CredentialState.Revoked) revert InvalidInput();
        if (_msgSender() != cred.issuer && _msgSender() != owner()) revert NotAuthorized();
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    function batchRevoke(uint256[] calldata ids) external nonReentrant whenNotPaused {
        uint256 n = ids.length;
        if (n == 0) revert EmptyArray();
        for (uint256 i = 0; i < n; ) {
            uint256 id = ids[i];
            if (id != 0) {
                Credential storage cred = _credentials[id];
                if (cred.id != 0 && cred.state != CredentialState.Revoked) {
                    if (_msgSender() == cred.issuer || _msgSender() == owner()) {
                        cred.state = CredentialState.Revoked;
                        emit CredentialRevoked(id, _msgSender());
                    }
                }
            }
            unchecked { ++i; }
        }
    }

    function updateCredentialMetadata(uint256 credentialId, string calldata newTitle, string calldata newDescription)
        external whenNotPaused credentialExists(credentialId)
    {
        if (bytes(newTitle).length == 0) revert EmptyTitle();

        Credential storage cred = _credentials[credentialId];
        if (_msgSender() != cred.issuer) revert NotAuthorized();
        if (cred.state == CredentialState.Revoked) revert InvalidInput();

        cred.title = newTitle;
        cred.description = newDescription;
        emit CredentialUpdated(credentialId, newTitle, newDescription, _msgSender());
    }

    // --- Views
    function getCredential(uint256 credentialId) external view credentialExists(credentialId) returns (Credential memory) {
        return _credentials[credentialId];
    }

    function totalCredentials() external view returns (uint256) {
        // counter started at 1 and increments after use; subtract 1 to get issued count
        return _credentialIdCounter.current() - 1;
    }

    function getUserCredentials(address user) external view returns (uint256[] memory) {
        return _userCredentialIds[user];
    }

    function getIssuerCredentials(address issuer) external view returns (uint256[] memory) {
        return _issuerCredentialIds[issuer];
    }

    function getUserCredentialsPaged(address user, uint256 cursor, uint256 pageSize)
        external view returns (uint256[] memory page, uint256 newCursor)
    {
        uint256 length = _userCredentialIds[user].length;
        if (cursor >= length) return (new uint256[](0), cursor);
        uint256 to = cursor + pageSize;
        if (to > length) to = length;
        page = new uint256[](to - cursor);
        for (uint256 i = cursor; i < to; ) {
            page[i - cursor] = _userCredentialIds[user][i];
            unchecked { ++i; }
        }
        return (page, to);
    }

    function getIssuerCredentialsPaged(address issuer, uint256 cursor, uint256 pageSize)
        external view returns (uint256[] memory page, uint256 newCursor)
    {
        uint256 length = _issuerCredentialIds[issuer].length;
        if (cursor >= length) return (new uint256[](0), cursor);
        uint256 to = cursor + pageSize;
        if (to > length) to = length;
        page = new uint256[](to - cursor);
        for (uint256 i = cursor; i < to; ) {
            page[i - cursor] = _issuerCredentialIds[issuer][i];
            unchecked { ++i; }
        }
        return (page, to);
    }

    // --- Admin utilities
    function ownerForceRevoke(uint256 credentialId) external onlyOwner credentialExists(credentialId) whenNotPaused {
        Credential storage cred = _credentials[credentialId];
        if (cred.state == CredentialState.Revoked) return;
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    function adminClearEmailBinding(string calldata email) external onlyOwner whenNotPaused {
        bytes32 h = keccak256(bytes(email));
        _emailHashToAddress[h] = address(0);
    }

    function renounceAllRoles() external onlyOwner whenNotPaused {
        // WARNING: calling this will remove the DEFAULT_ADMIN_ROLE from owner. Be careful.
        revokeRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    /**
     * @notice Returns an existing credential id issued by the caller for the subject/title (if any), otherwise issues a new one.
     */
    function issueIfNotExists(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        uint256[] storage issuerList = _issuerCredentialIds[_msgSender()];
        bytes32 titleHash = keccak256(bytes(title));
        for (uint256 i = 0; i < issuerList.length; ) {
            Credential storage c = _credentials[issuerList[i]];
            if (c.subject == subject && keccak256(bytes(c.title)) == titleHash && c.state != CredentialState.Revoked) {
                return c.id;
            }
            unchecked { ++i; }
        }
        return _issueCredential(_msgSender(), subject, title, description);
    }

    // small helper view for frontends
    function getCredentialState(uint256 credentialId) external view returns (CredentialState) {
        return _credentials[credentialId].state;
    }

    // --- ERC165 / AccessControl compatibility
    function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControl) returns (bool) {
        return AccessControl.supportsInterface(interfaceId);
    }
}

