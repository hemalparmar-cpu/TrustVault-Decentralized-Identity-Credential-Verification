// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract TrustVault {
    struct Credential {
        string title;
        string description;
        address issuer;
        uint256 timestamp;
        bool isVerified;
    }
    
    struct Identity {
        string name;
        string email;
        bool isRegistered;
        uint256 credentialCount;
    }
    
    mapping(address => Identity) public identities;
    mapping(address => mapping(uint256 => Credential)) public credentials;
    mapping(address => bool) public verifiedIssuers;
    
    address public owner;
    uint256 public totalUsers;
    
    event IdentityRegistered(address indexed user, string name);
    event CredentialIssued(address indexed user, address indexed issuer, string title);
    event CredentialVerified(address indexed user, uint256 credentialId);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can perform this action");
        _;
    }
    
    modifier onlyRegistered() {
        require(identities[msg.sender].isRegistered, "User not registered");
        _;
    }
    
    constructor() {
        owner = msg.sender;
        verifiedIssuers[msg.sender] = true;
    }
    
    // Core Function 1: Register Identity
    function registerIdentity(string memory _name, string memory _email) external {
        require(!identities[msg.sender].isRegistered, "Identity already registered");
        require(bytes(_name).length > 0, "Name cannot be empty");
        require(bytes(_email).length > 0, "Email cannot be empty");
        
        identities[msg.sender] = Identity({
            name: _name,
            email: _email,
            isRegistered: true,
            credentialCount: 0
        });
        
        totalUsers++;
        emit IdentityRegistered(msg.sender, _name);
    }
    
    // Core Function 2: Issue Credential
    function issueCredential(
        address _user,
        string memory _title,
        string memory _description
    ) external {
        require(verifiedIssuers[msg.sender], "Not a verified issuer");
        require(identities[_user].isRegistered, "User not registered");
        require(bytes(_title).length > 0, "Title cannot be empty");
        
        uint256 credentialId = identities[_user].credentialCount;
        
        credentials[_user][credentialId] = Credential({
            title: _title,
            description: _description,
            issuer: msg.sender,
            timestamp: block.timestamp,
            isVerified: true
        });
        
        identities[_user].credentialCount++;
        emit CredentialIssued(_user, msg.sender, _title);
    }
    
    // Core Function 3: Verify Credential
    function verifyCredential(address _user, uint256 _credentialId) 
        external 
        view 
        returns (
            string memory title,
            string memory description,
            address issuer,
            uint256 timestamp,
            bool isVerified
        ) 
    {
        require(identities[_user].isRegistered, "User not registered");
        require(_credentialId < identities[_user].credentialCount, "Credential does not exist");
        
        Credential memory cred = credentials[_user][_credentialId];
        return (
            cred.title,
            cred.description,
            cred.issuer,
            cred.timestamp,
            cred.isVerified
        );
    }
    
    // Core Function 4: Revoke Credential
    function revokeCredential(address _user, uint256 _credentialId) external {
        require(verifiedIssuers[msg.sender], "Not a verified issuer");
        require(identities[_user].isRegistered, "User not registered");
        require(_credentialId < identities[_user].credentialCount, "Credential does not exist");

        Credential storage cred = credentials[_user][_credentialId];
        require(cred.issuer == msg.sender, "Only the issuer can revoke this credential");

        cred.isVerified = false; // Mark the credential as revoked or invalid
        emit CredentialVerified(_user, _credentialId); // Emit event to reflect the status change
    }
    
    // Additional helper functions
    function addVerifiedIssuer(address _issuer) external onlyOwner {
        verifiedIssuers[_issuer] = true;
    }
    
    function getUserCredentialCount(address _user) external view returns (uint256) {
        return identities[_user].credentialCount;
    }
    
    function getIdentity(address _user) external view returns (
        string memory name,
        string memory email,
        bool isRegistered,
        uint256 credentialCount
    ) {
        Identity memory identity = identities[_user];
        return (identity.name, identity.email, identity.isRegistered, identity.credentialCount);
    }
}
