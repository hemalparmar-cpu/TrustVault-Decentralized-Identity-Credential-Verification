// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title TrustVaultPlusV5 (refined)
 * @notice Gas- and safety-focused refinement of the supplied TrustVaultPlusV5.
 * - Consolidates issue logic into internal function to avoid redundant modifier checks
 * - Uses local variables and `unchecked` where safe to slightly reduce gas
 * - Tightened visibility and immutability where applicable
 * - Minor API ergonomics (helpers, state queries)
 * - Keeps same external behaviour and events
 *
 * Requirements:
 *   npm i @openzeppelin/contracts
 */

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

contract TrustVaultPlusV5 is AccessControl, Ownable, Pausable, ReentrancyGuard {
    using Counters for Counters.Counter;
    using EnumerableSet for EnumerableSet.AddressSet;

    bytes32 public constant ISSUER_ROLE = keccak256("ISSUER_ROLE");

    enum CredentialState { Issued, Verified, Revoked }

    struct Credential {
        uint256 id;
        address subject;
        address issuer;
        string title;
        string description; // free text or IPFS hash (recommended)
        uint64 timestamp;
        CredentialState state;
    }

    struct Identity {
        string name;
        string email;
        bool isRegistered;
    }

    // -- Storage
    Counters.Counter private _credentialIdCounter;
    mapping(address => Identity) private _identities;
    mapping(bytes32 => address) private _emailHashToAddress;

    mapping(uint256 => Credential) private _credentials;
    mapping(address => uint256[]) private _userCredentialIds;
    mapping(address => uint256[]) private _issuerCredentialIds;

    EnumerableSet.AddressSet private _issuers; // to enumerate issuers

    // -- Events
    event IdentityRegistered(address indexed user, string name, string email);
    event IdentityUpdated(address indexed user, string name, string email);
    event IdentityDeregistered(address indexed user);

    event IssuerGranted(address indexed issuer);
    event IssuerRevoked(address indexed issuer);

    event CredentialIssued(uint256 indexed credentialId, address indexed subject, address indexed issuer, string title);
    event CredentialBatchIssued(uint256[] ids, address indexed issuer);
    event CredentialVerified(uint256 indexed credentialId, address indexed verifier);
    event CredentialRevoked(uint256 indexed credentialId, address indexed revokedBy);
    event CredentialUpdated(uint256 indexed credentialId, string newTitle, string newDescription, address indexed updatedBy);

    // -- Constructor
    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(ISSUER_ROLE, _msgSender());
        transferOwnership(_msgSender());

        // Start IDs at 1 for clearer truthiness
        _credentialIdCounter.increment();

        // add to EnumerableSet too
        _issuers.add(_msgSender());
    }

    // -- Modifiers
    modifier onlyRegistered(address user) {
        require(_identities[user].isRegistered, "User not registered");
        _;
    }

    modifier credentialExists(uint256 credentialId) {
        require(credentialId != 0 && _credentials[credentialId].id != 0, "Credential not found");
        _;
    }

    modifier onlyIssuer() {
        require(hasRole(ISSUER_ROLE, _msgSender()), "Caller is not an issuer");
        _;
    }

    // -- Identity management
    function registerIdentity(string calldata name, string calldata email) external whenNotPaused {
        require(!_identities[_msgSender()].isRegistered, "Already registered");
        require(bytes(name).length > 0 && bytes(email).length > 0, "Invalid name/email");

        bytes32 h = keccak256(bytes(email));
        require(_emailHashToAddress[h] == address(0), "Email already used");

        _identities[_msgSender()] = Identity({ name: name, email: email, isRegistered: true });
        _emailHashToAddress[h] = _msgSender();

        emit IdentityRegistered(_msgSender(), name, email);
    }

    function updateIdentity(string calldata name, string calldata email) external onlyRegistered(_msgSender()) whenNotPaused {
        require(bytes(name).length > 0 && bytes(email).length > 0, "Invalid name/email");

        Identity storage idRec = _identities[_msgSender()];
        bytes32 oldHash = keccak256(bytes(idRec.email));
        bytes32 newHash = keccak256(bytes(email));

        if (oldHash != newHash) {
            require(_emailHashToAddress[newHash] == address(0), "Email already used");
            if (_emailHashToAddress[oldHash] == _msgSender()) {
                _emailHashToAddress[oldHash] = address(0);
            }
            _emailHashToAddress[newHash] = _msgSender();
            idRec.email = email;
        }
        idRec.name = name;

        emit IdentityUpdated(_msgSender(), name, email);
    }

    function deregisterIdentity() external onlyRegistered(_msgSender()) whenNotPaused {
        Identity storage idRec = _identities[_msgSender()];
        bytes32 h = keccak256(bytes(idRec.email));
        if (_emailHashToAddress[h] == _msgSender()) {
            _emailHashToAddress[h] = address(0);
        }
        delete _identities[_msgSender()];
        emit IdentityDeregistered(_msgSender());
    }

    function getIdentity(address user) external view returns (Identity memory) {
        return _identities[user];
    }

    function getIdentityByEmail(string calldata email) external view returns (address) {
        if (bytes(email).length == 0) return address(0);
        return _emailHashToAddress[keccak256(bytes(email))];
    }

    function isEmailBound(string calldata email) external view returns (bool) {
        if (bytes(email).length == 0) return false;
        return _emailHashToAddress[keccak256(bytes(email))] != address(0);
    }

    // -- Issuer management (owner)
    function grantIssuer(address account) external onlyOwner whenNotPaused {
        require(account != address(0), "Zero address");
        grantRole(ISSUER_ROLE, account);
        _issuers.add(account);
        emit IssuerGranted(account);
    }

    function revokeIssuer(address account) external onlyOwner whenNotPaused {
        require(account != address(0), "Zero address");
        revokeRole(ISSUER_ROLE, account);
        _issuers.remove(account);
        emit IssuerRevoked(account);
    }

    function isIssuer(address account) external view returns (bool) {
        return hasRole(ISSUER_ROLE, account);
    }

    function renounceIssuerRole() external whenNotPaused {
        renounceRole(ISSUER_ROLE, _msgSender());
        _issuers.remove(_msgSender());
        emit IssuerRevoked(_msgSender());
    }

    function listIssuers(uint256 cursor, uint256 pageSize) external view returns (address[] memory page, uint256 newCursor) {
        uint256 total = _issuers.length();
        if (cursor >= total) {
            return (new address[](0), cursor);
        }
        uint256 to = cursor + pageSize;
        if (to > total) to = total;
        page = new address[](to - cursor);
        for (uint256 i = cursor; i < to; ++i) {
            page[i - cursor] = _issuers.at(i);
        }
        return (page, to);
    }

    // -- Pause / Unpause
    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // -- Credential lifecycle helpers
    function _nextId() internal returns (uint256) {
        uint256 id = _credentialIdCounter.current();
        _credentialIdCounter.increment();
        return id;
    }

    /**
     * @dev Core internal issue function (no modifiers). Use public wrappers to add access control.
     */
    function _issueCredential(address issuer, address subject, string calldata title, string calldata description)
        internal returns (uint256)
    {
        require(subject != address(0) && bytes(title).length > 0, "Invalid input");

        uint256 cid = _nextId();

        // Save credential
        _credentials[cid] = Credential({
            id: cid,
            subject: subject,
            issuer: issuer,
            title: title,
            description: description,
            timestamp: uint64(block.timestamp),
            state: CredentialState.Issued
        });

        _userCredentialIds[subject].push(cid);
        _issuerCredentialIds[issuer].push(cid);

        emit CredentialIssued(cid, subject, issuer, title);
        return cid;
    }

    /**
     * @notice Issue a single credential. Subject must already be registered.
     */
    function issueCredential(address subject, string calldata title, string calldata description)
        public whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        return _issueCredential(_msgSender(), subject, title, description);
    }

    /**
     * @notice Batch issue: nonReentrant and preserves original behaviour. Returns array of ids.
     */
    function batchIssueCredentials(
        address[] calldata subjects,
        string[] calldata titles,
        string[] calldata descriptions
    ) external nonReentrant whenNotPaused onlyIssuer returns (uint256[] memory) {
        uint256 n = subjects.length;
        require(n > 0, "Empty subjects");
        require(titles.length == n && descriptions.length == n, "Array length mismatch");

        uint256[] memory issuedIds = new uint256[](n);
        for (uint256 i = 0; i < n; ++i) {
            // use internal issuer to avoid re-evaluating onlyIssuer each iteration
            issuedIds[i] = _issueCredential(_msgSender(), subjects[i], titles[i], descriptions[i]);
        }
        emit CredentialBatchIssued(issuedIds, _msgSender());
        return issuedIds;
    }

    /**
     * @notice Issue and mark verified atomically.
     */
    function issueAndVerify(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        uint256 cid = _issueCredential(_msgSender(), subject, title, description);
        _credentials[cid].state = CredentialState.Verified;
        emit CredentialVerified(cid, _msgSender());
        return cid;
    }

    function verifyCredential(uint256 credentialId) external whenNotPaused onlyIssuer credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        require(cred.state == CredentialState.Issued, "Not in issued state");
        cred.state = CredentialState.Verified;
        emit CredentialVerified(credentialId, _msgSender());
    }

    function batchVerify(uint256[] calldata credentialIds) external whenNotPaused onlyIssuer {
        uint256 len = credentialIds.length;
        require(len > 0, "Empty list");
        for (uint256 i = 0; i < len; ++i) {
            uint256 id = credentialIds[i];
            if (id == 0) continue;
            Credential storage cred = _credentials[id];
            if (cred.id == 0) continue;
            if (cred.state != CredentialState.Issued) continue;
            cred.state = CredentialState.Verified;
            emit CredentialVerified(id, _msgSender());
        }
    }

    // Revoke: only issuer of that credential or owner
    function revokeCredential(uint256 credentialId) external whenNotPaused credentialExists(credentialId) {
        Credential storage cred = _credentials[credentialId];
        require(cred.state != CredentialState.Revoked, "Already revoked");
        require(_msgSender() == cred.issuer || _msgSender() == owner(), "Not authorized");
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    function batchRevoke(uint256[] calldata ids) external nonReentrant whenNotPaused {
        uint256 n = ids.length;
        require(n > 0, "Empty list");
        for (uint256 i = 0; i < n; ++i) {
            uint256 id = ids[i];
            if (id == 0) continue;
            Credential storage cred = _credentials[id];
            if (cred.id == 0) continue;
            if (cred.state == CredentialState.Revoked) continue;
            if (_msgSender() != cred.issuer && _msgSender() != owner()) continue; // skip unauthorized
            cred.state = CredentialState.Revoked;
            emit CredentialRevoked(id, _msgSender());
        }
    }

    function updateCredentialMetadata(uint256 credentialId, string calldata newTitle, string calldata newDescription)
        external whenNotPaused credentialExists(credentialId)
    {
        require(bytes(newTitle).length > 0, "Empty title");

        Credential storage cred = _credentials[credentialId];
        require(_msgSender() == cred.issuer, "Only issuer can update");
        require(cred.state != CredentialState.Revoked, "Cannot update revoked credential");

        cred.title = newTitle;
        cred.description = newDescription;
        emit CredentialUpdated(credentialId, newTitle, newDescription, _msgSender());
    }

    // -- Views
    function getCredential(uint256 credentialId) external view credentialExists(credentialId) returns (Credential memory) {
        return _credentials[credentialId];
    }

    function totalCredentials() external view returns (uint256) {
        return _credentialIdCounter.current() - 1;
    }

    function getUserCredentials(address user) external view returns (uint256[] memory) {
        return _userCredentialIds[user];
    }

    function getIssuerCredentials(address issuer) external view returns (uint256[] memory) {
        return _issuerCredentialIds[issuer];
    }

    function getUserCredentialsPaged(address user, uint256 cursor, uint256 pageSize)
        external view returns (uint256[] memory page, uint256 newCursor)
    {
        uint256 length = _userCredentialIds[user].length;
        if (cursor >= length) return (new uint256[](0), cursor);

        uint256 to = cursor + pageSize;
        if (to > length) to = length;
        page = new uint256[](to - cursor);
        for (uint256 i = cursor; i < to; ++i) {
            page[i - cursor] = _userCredentialIds[user][i];
        }
        return (page, to);
    }

    function getIssuerCredentialsPaged(address issuer, uint256 cursor, uint256 pageSize)
        external view returns (uint256[] memory page, uint256 newCursor)
    {
        uint256 length = _issuerCredentialIds[issuer].length;
        if (cursor >= length) return (new uint256[](0), cursor);

        uint256 to = cursor + pageSize;
        if (to > length) to = length;
        page = new uint256[](to - cursor);
        for (uint256 i = cursor; i < to; ++i) {
            page[i - cursor] = _issuerCredentialIds[issuer][i];
        }
        return (page, to);
    }

    // -- Admin utilities
    function ownerForceRevoke(uint256 credentialId) external onlyOwner credentialExists(credentialId) whenNotPaused {
        Credential storage cred = _credentials[credentialId];
        if (cred.state == CredentialState.Revoked) return;
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(credentialId, _msgSender());
    }

    function adminClearEmailBinding(string calldata email) external onlyOwner whenNotPaused {
        bytes32 h = keccak256(bytes(email));
        _emailHashToAddress[h] = address(0);
    }

    function renounceAllRoles() external onlyOwner whenNotPaused {
        // WARNING: calling this will remove the DEFAULT_ADMIN_ROLE from owner. Be careful.
        revokeRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    function issueIfNotExists(address subject, string calldata title, string calldata description)
        external whenNotPaused onlyIssuer onlyRegistered(subject) returns (uint256)
    {
        uint256[] storage issuerList = _issuerCredentialIds[_msgSender()];
        bytes32 titleHash = keccak256(bytes(title));
        for (uint256 i = 0; i < issuerList.length; ++i) {
            Credential storage c = _credentials[issuerList[i]];
            if (c.subject == subject && keccak256(bytes(c.title)) == titleHash && c.state != CredentialState.Revoked) {
                return c.id;
            }
        }
        return _issueCredential(_msgSender(), subject, title, description);
    }

    // small helper view for frontends
    function getCredentialState(uint256 credentialId) external view returns (CredentialState) {
        return _credentials[credentialId].state;
    }
}

