// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title TrustVaultPlus
/// @notice Identity registry + credential issuance, verification and revocation vault (v2 - enhanced)
/// @author
contract TrustVaultPlus {
    // ----------------------------
    // STRUCTS & ENUMS
    // ----------------------------
    enum CredentialState { Issued, Verified, Revoked }

    struct Credential {
        uint256 id;              // global credential id (starts at 1)
        address subject;         // who the credential was issued to
        address issuer;          // who issued it
        string title;
        string description;
        uint256 timestamp;       // issued timestamp
        CredentialState state;
    }

    struct Identity {
        string name;
        string email;
        bool isRegistered;
    }

    // ----------------------------
    // STATE
    // ----------------------------
    address public owner;
    uint256 public totalUsers;
    uint256 private _nextCredentialId;

    // identities
    mapping(address => Identity) private identities;
    // Email guard: map keccak256(email) -> address
    mapping(bytes32 => address) private emailHashToAddress;

    // credentials storage
    mapping(uint256 => Credential) private credentials;         // global id -> Credential
    mapping(address => uint256[]) private userCredentialIds;    // user -> list of credential ids
    mapping(address => uint256[]) private issuerCredentialIds;  // issuer -> list of credential ids

    // issuer registry
    mapping(address => bool) public verifiedIssuers;

    // pause feature
    bool public paused;

    // ----------------------------
    // EVENTS
    // ----------------------------
    event IdentityRegistered(address indexed user, string name, string email);
    event IdentityUpdated(address indexed user, string name, string email);
    event IdentityDeregistered(address indexed user);
    event IssuerStatusUpdated(address indexed issuer, bool status);
    event CredentialIssued(uint256 indexed credentialId, address indexed subject, address indexed issuer, string title);
    event CredentialVerified(uint256 indexed credentialId, address indexed verifier);
    event CredentialRevoked(uint256 indexed credentialId, address indexed revokedBy);
    event CredentialUpdated(uint256 indexed credentialId, string newTitle, string newDescription, address indexed updatedBy);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address indexed by);
    event Unpaused(address indexed by);

    // ----------------------------
    // MODIFIERS
    // ----------------------------
    modifier onlyOwner() {
        require(msg.sender == owner, "TrustVaultPlus: only owner");
        _;
    }

    modifier onlyRegistered(address _user) {
        require(identities[_user].isRegistered, "TrustVaultPlus: user not registered");
        _;
    }

    modifier onlyVerifiedIssuer() {
        require(verifiedIssuers[msg.sender], "TrustVaultPlus: not a verified issuer");
        _;
    }

    modifier credentialExists(uint256 _credentialId) {
        // since ids start at 1, id != 0 implies exists only after issuance
        require(_credentialId != 0 && credentials[_credentialId].id != 0, "TrustVaultPlus: credential not found");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "TrustVaultPlus: paused");
        _;
    }

    // ----------------------------
    // CONSTRUCTOR
    // ----------------------------
    constructor() {
        owner = msg.sender;
        _nextCredentialId = 1; // start ids at 1 for clarity
        // Optionally make deployer a verified issuer
        verifiedIssuers[msg.sender] = true;
        paused = false;
    }

    // ----------------------------
    // IDENTITY FUNCTIONS
    // ----------------------------

    /// @notice Register the caller as an identity
    function registerIdentity(string calldata _name, string calldata _email) external whenNotPaused {
        require(!identities[msg.sender].isRegistered, "TrustVaultPlus: already registered");
        require(bytes(_name).length > 0, "TrustVaultPlus: empty name");
        require(bytes(_email).length > 0, "TrustVaultPlus: empty email");

        bytes32 h = keccak256(bytes(_email));
        require(emailHashToAddress[h] == address(0), "TrustVaultPlus: email already used");

        identities[msg.sender] = Identity({ name: _name, email: _email, isRegistered: true });
        emailHashToAddress[h] = msg.sender;
        totalUsers += 1;

        emit IdentityRegistered(msg.sender, _name, _email);
    }

    /// @notice Update name/email for caller
    function updateIdentity(string calldata _name, string calldata _email) external onlyRegistered(msg.sender) whenNotPaused {
        require(bytes(_name).length > 0, "TrustVaultPlus: empty name");
        require(bytes(_email).length > 0, "TrustVaultPlus: empty email");

        string memory oldEmail = identities[msg.sender].email;
        if (keccak256(bytes(oldEmail)) != keccak256(bytes(_email))) {
            bytes32 newH = keccak256(bytes(_email));
            require(emailHashToAddress[newH] == address(0), "TrustVaultPlus: email already used");
            // free old email hash
            if (bytes(oldEmail).length != 0) {
                bytes32 oldH = keccak256(bytes(oldEmail));
                emailHashToAddress[oldH] = address(0);
            }
            emailHashToAddress[newH] = msg.sender;
            identities[msg.sender].email = _email;
        }

        identities[msg.sender].name = _name;

        emit IdentityUpdated(msg.sender, _name, _email);
    }

    /// @notice Deregister the caller (credentials remain)
    function deregisterIdentity() external onlyRegistered(msg.sender) whenNotPaused {
        string memory oldEmail = identities[msg.sender].email;
        if (bytes(oldEmail).length != 0) {
            bytes32 oldH = keccak256(bytes(oldEmail));
            emailHashToAddress[oldH] = address(0);
        }

        identities[msg.sender].isRegistered = false;
        totalUsers -= 1;
        emit IdentityDeregistered(msg.sender);
    }

    /// @notice Lookup address by email (returns address(0) if none)
    function getIdentityByEmail(string calldata _email) external view returns (address) {
        if (bytes(_email).length == 0) { return address(0); }
        return emailHashToAddress[keccak256(bytes(_email))];
    }

    // ----------------------------
    // ISSUER ADMIN
    // ----------------------------

    /// @notice Add or remove a verified issuer
    function updateVerifiedIssuer(address _issuer, bool _status) public onlyOwner whenNotPaused {
        require(_issuer != address(0), "TrustVaultPlus: zero address");
        require(verifiedIssuers[_issuer] != _status, "TrustVaultPlus: no change");
        verifiedIssuers[_issuer] = _status;
        emit IssuerStatusUpdated(_issuer, _status);
    }

    /// @notice Update multiple issuer statuses in one call
    function updateVerifiedIssuersBulk(address[] calldata _issuers, bool[] calldata _statuses) external onlyOwner whenNotPaused {
        require(_issuers.length == _statuses.length, "TrustVaultPlus: length mismatch");
        for (uint256 i = 0; i < _issuers.length; i++) {
            address iss = _issuers[i];
            bool st = _statuses[i];
            if (iss != address(0) && verifiedIssuers[iss] != st) {
                verifiedIssuers[iss] = st;
                emit IssuerStatusUpdated(iss, st);
            }
        }
    }

    /// @notice Transfer ownership
    function transferOwnership(address _newOwner) external onlyOwner whenNotPaused {
        require(_newOwner != address(0), "TrustVaultPlus: zero address");
        address previousOwner = owner;
        owner = _newOwner;
        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    /// @notice Renounce ownership (irreversible)
    function renounceOwnership() external onlyOwner whenNotPaused {
        address previousOwner = owner;
        owner = address(0);
        emit OwnershipTransferred(previousOwner, address(0));
    }

    // ----------------------------
    // PAUSE / EMERGENCY
    // ----------------------------
    function pause() external onlyOwner {
        require(!paused, "TrustVaultPlus: already paused");
        paused = true;
        emit Paused(msg.sender);
    }

    function unpause() external onlyOwner {
        require(paused, "TrustVaultPlus: not paused");
        paused = false;
        emit Unpaused(msg.sender);
    }

    // ----------------------------
    // CREDENTIAL LIFECYCLE
    // ----------------------------

    /// @notice Issue a credential to a registered user. Caller must be a verified issuer.
    /// @dev Issued credentials start in state `Issued` and may be verified later.
    function issueCredential(
        address _subject,
        string calldata _title,
        string calldata _description
    ) external onlyVerifiedIssuer onlyRegistered(_subject) whenNotPaused returns (uint256) {
        require(_subject != address(0), "TrustVaultPlus: zero subject");
        require(bytes(_title).length > 0, "TrustVaultPlus: empty title");

        uint256 cid = _nextCredentialId++;
        Credential memory cred = Credential({
            id: cid,
            subject: _subject,
            issuer: msg.sender,
            title: _title,
            description: _description,
            timestamp: block.timestamp,
            state: CredentialState.Issued
        });

        credentials[cid] = cred;
        userCredentialIds[_subject].push(cid);
        issuerCredentialIds[msg.sender].push(cid);

        emit CredentialIssued(cid, _subject, msg.sender, _title);
        return cid;
    }

    /// @notice Issue and immediately verify (convenience). Caller must be verified issuer.
    function issueAndVerify(
        address _subject,
        string calldata _title,
        string calldata _description
    ) external onlyVerifiedIssuer onlyRegistered(_subject) whenNotPaused returns (uint256) {
        uint256 cid = issueCredential(_subject, _title, _description);
        // mark as verified
        Credential storage cred = credentials[cid];
        cred.state = CredentialState.Verified;
        emit CredentialVerified(cid, msg.sender);
        return cid;
    }

    /// @notice Mark an issued credential as Verified. Caller must be a verified issuer.
    /// @dev Only credentials in state Issued can be verified.
    function verifyCredential(uint256 _credentialId) external onlyVerifiedIssuer credentialExists(_credentialId) whenNotPaused {
        Credential storage cred = credentials[_credentialId];
        require(cred.state == CredentialState.Issued, "TrustVaultPlus: not in issued state");

        cred.state = CredentialState.Verified;
        emit CredentialVerified(_credentialId, msg.sender);
    }

    /// @notice Revoke a credential. Can be called by credential issuer or contract owner.
    function revokeCredential(uint256 _credentialId) external credentialExists(_credentialId) whenNotPaused {
        Credential storage cred = credentials[_credentialId];
        require(cred.state != CredentialState.Revoked, "TrustVaultPlus: already revoked");
        require(msg.sender == cred.issuer || msg.sender == owner, "TrustVaultPlus: not authorized to revoke");

        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(_credentialId, msg.sender);
    }

    /// @notice Update title/description for a credential. Only issuer can update and credential mustn't be revoked.
    function updateCredentialMetadata(
        uint256 _credentialId,
        string calldata _newTitle,
        string calldata _newDescription
    ) external credentialExists(_credentialId) whenNotPaused {
        require(bytes(_newTitle).length > 0, "TrustVaultPlus: empty title");
        Credential storage cred = credentials[_credentialId];
        require(msg.sender == cred.issuer, "TrustVaultPlus: only issuer can update");
        require(cred.state != CredentialState.Revoked, "TrustVaultPlus: cannot update revoked credential");

        cred.title = _newTitle;
        cred.description = _newDescription;

        emit CredentialUpdated(_credentialId, _newTitle, _newDescription, msg.sender);
    }

    // ----------------------------
    // VIEW / GETTERS
    // ----------------------------

    /// @notice Get a credential by global id
    function getCredential(uint256 _credentialId)
        external
        view
        credentialExists(_credentialId)
        returns (
            uint256 id,
            address subject,
            address issuer,
            string memory title,
            string memory description,
            uint256 timestamp,
            CredentialState state
        )
    {
        Credential memory cred = credentials[_credentialId];
        return (cred.id, cred.subject, cred.issuer, cred.title, cred.description, cred.timestamp, cred.state);
    }

    /// @notice Batch fetch credentials by ids (returns parallel arrays)
    /// @dev if an id is zero/invalid it will return default values for that slot (caller should ensure ids valid)
    function batchGetCredentials(uint256[] calldata _ids)
        external
        view
        returns (
            uint256[] memory ids,
            address[] memory subjects,
            address[] memory issuers,
            string[] memory titles,
            string[] memory descriptions,
            uint256[] memory timestamps,
            CredentialState[] memory states
        )
    {
        uint256 n = _ids.length;
        ids = new uint256[](n);
        subjects = new address[](n);
        issuers = new address[](n);
        titles = new string[](n);
        descriptions = new string[](n);
        timestamps = new uint256[](n);
        states = new CredentialState[](n);

        for (uint256 i = 0; i < n; i++) {
            uint256 id = _ids[i];
            Credential memory c = credentials[id];
            ids[i] = c.id;
            subjects[i] = c.subject;
            issuers[i] = c.issuer;
            titles[i] = c.title;
            descriptions[i] = c.description;
            timestamps[i] = c.timestamp;
            states[i] = c.state;
        }
    }

    /// @notice Get number of credentials a user has (including revoked)
    function getUserCredentialCount(address _user) external view returns (uint256) {
        return userCredentialIds[_user].length;
    }

    /// @notice Get user's credential id at index (useful for enumeration)
    function getUserCredentialIdAt(address _user, uint256 _index) external view returns (uint256) {
        require(_index < userCredentialIds[_user].length, "TrustVaultPlus: index OOB");
        return userCredentialIds[_user][_index];
    }

    /// @notice Get all credential ids for a user
    function getUserCredentials(address _user) external view returns (uint256[] memory) {
        return userCredentialIds[_user];
    }

    /// @notice Get all credential ids for a user (paged)
    function getUserCredentialsPaged(address _user, uint256 _start, uint256 _count) external view returns (uint256[] memory) {
        uint256 total = userCredentialIds[_user].length;
        if (_start >= total || _count == 0) { return new uint256; }

        uint256 end = _start + _count;
        if (end > total) { end = total; }
        uint256 lengthOut = end - _start;
        uint256[] memory out = new uint256[](lengthOut);
        for (uint256 i = 0; i < lengthOut; i++) {
            out[i] = userCredentialIds[_user][_start + i];
        }
        return out;
    }

    /// @notice Get number of credentials an issuer has issued
    function getIssuerCredentialCount(address _issuer) external view returns (uint256) {
        return issuerCredentialIds[_issuer].length;
    }

    /// @notice Get all credential ids issued by an issuer
    function getIssuerCredentials(address _issuer) external view returns (uint256[] memory) {
        return issuerCredentialIds[_issuer];
    }

    /// @notice Get all credential ids issued by an issuer (paged)
    function getIssuerCredentialsPaged(address _issuer, uint256 _start, uint256 _count) external view returns (uint256[] memory) {
        uint256 total = issuerCredentialIds[_issuer].length;
        if (_start >= total || _count == 0) { return new uint256; }

        uint256 end = _start + _count;
        if (end > total) { end = total; }
        uint256 lengthOut = end - _start;
        uint256[] memory out = new uint256[](lengthOut);
        for (uint256 i = 0; i < lengthOut; i++) {
            out[i] = issuerCredentialIds[_issuer][_start + i];
        }
        return out;
    }

    /// @notice Get identity info
    function getIdentity(address _user)
        external
        view
        returns (string memory name, string memory email, bool registered)
    {
        Identity memory id = identities[_user];
        return (id.name, id.email, id.isRegistered);
    }

    /// @notice Check whether an address is a verified issuer
    function isVerifiedIssuer(address _addr) external view returns (bool) {
        return verifiedIssuers[_addr];
    }

    /// @notice Returns the total number of credentials ever issued (including revoked).
    function totalCredentials() external view returns (uint256) {
        return _nextCredentialId - 1;
    }

    /// @notice Returns credential ids of a user filtered by state.
    /// @dev This is a view helper that iterates the user's credential ids and filters by state.
    function getUserCredentialIdsByState(address _user, CredentialState _state) external view returns (uint256[] memory) {
        uint256 total = userCredentialIds[_user].length;
        // first pass: count matches
        uint256 count = 0;
        for (uint256 i = 0; i < total; i++) {
            uint256 id = userCredentialIds[_user][i];
            if (credentials[id].state == _state) { count++; }
        }
        // second pass: collect
        uint256[] memory out = new uint256[](count);
        uint256 idx = 0;
        for (uint256 i = 0; i < total; i++) {
            uint256 id = userCredentialIds[_user][i];
            if (credentials[id].state == _state) {
                out[idx++] = id;
            }
        }
        return out;
    }

    /// @notice Returns credential ids of an issuer filtered by state.
    function getIssuerCredentialIdsByState(address _issuer, CredentialState _state) external view returns (uint256[] memory) {
        uint256 total = issuerCredentialIds[_issuer].length;
        uint256 count = 0;
        for (uint256 i = 0; i < total; i++) {
            uint256 id = issuerCredentialIds[_issuer][i];
            if (credentials[id].state == _state) { count++; }
        }
        uint256[] memory out = new uint256[](count);
        uint256 idx = 0;
        for (uint256 i = 0; i < total; i++) {
            uint256 id = issuerCredentialIds[_issuer][i];
            if (credentials[id].state == _state) {
                out[idx++] = id;
            }
        }
        return out;
    }
}
