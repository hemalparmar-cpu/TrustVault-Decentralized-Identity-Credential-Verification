// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title TrustVaultPlusV2
/// @notice Identity registry + credential issuance, verification, and revocation vault (refactored)
contract TrustVaultPlusV2 {
    // ----------------------------
    // ENUMS & STRUCTS
    // ----------------------------
    enum CredentialState { Issued, Verified, Revoked }

    struct Credential {
        uint256 id;
        address subject;
        address issuer;
        string title;
        string description;
        uint256 timestamp;
        CredentialState state;
    }

    struct Identity {
        string name;
        string email;
        bool isRegistered;
    }

    // ----------------------------
    // STATE VARIABLES
    // ----------------------------
    address public owner;
    uint256 public totalUsers;
    uint256 private _nextCredentialId;

    mapping(address => Identity) private identities;
    mapping(bytes32 => address) private emailHashToAddress;

    mapping(uint256 => Credential) private credentials;
    mapping(address => uint256[]) private userCredentialIds;
    mapping(address => uint256[]) private issuerCredentialIds;

    mapping(address => bool) public verifiedIssuers;

    bool public paused;

    // ----------------------------
    // EVENTS
    // ----------------------------
    event IdentityRegistered(address indexed user, string name, string email);
    event IdentityUpdated(address indexed user, string name, string email);
    event IdentityDeregistered(address indexed user);
    event IssuerStatusUpdated(address indexed issuer, bool status);
    event CredentialIssued(uint256 indexed credentialId, address indexed subject, address indexed issuer, string title);
    event CredentialVerified(uint256 indexed credentialId, address indexed verifier);
    event CredentialRevoked(uint256 indexed credentialId, address indexed revokedBy);
    event CredentialUpdated(uint256 indexed credentialId, string newTitle, string newDescription, address indexed updatedBy);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address indexed by);
    event Unpaused(address indexed by);

    // ----------------------------
    // MODIFIERS
    // ----------------------------
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    modifier onlyRegistered(address _user) {
        require(identities[_user].isRegistered, "User not registered");
        _;
    }

    modifier onlyVerifiedIssuer() {
        require(verifiedIssuers[msg.sender], "Not a verified issuer");
        _;
    }

    modifier credentialExists(uint256 _credentialId) {
        require(_credentialId != 0 && credentials[_credentialId].id != 0, "Credential not found");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "Contract paused");
        _;
    }

    // ----------------------------
    // CONSTRUCTOR
    // ----------------------------
    constructor() {
        owner = msg.sender;
        _nextCredentialId = 1;
        verifiedIssuers[msg.sender] = true;
        paused = false;
    }

    // ----------------------------
    // IDENTITY FUNCTIONS
    // ----------------------------
    function registerIdentity(string calldata _name, string calldata _email) external whenNotPaused {
        require(!identities[msg.sender].isRegistered, "Already registered");
        require(bytes(_name).length > 0 && bytes(_email).length > 0, "Invalid name/email");

        bytes32 h = keccak256(bytes(_email));
        require(emailHashToAddress[h] == address(0), "Email already used");

        identities[msg.sender] = Identity({name: _name, email: _email, isRegistered: true});
        emailHashToAddress[h] = msg.sender;
        totalUsers += 1;

        emit IdentityRegistered(msg.sender, _name, _email);
    }

    function updateIdentity(string calldata _name, string calldata _email) external onlyRegistered(msg.sender) whenNotPaused {
        require(bytes(_name).length > 0 && bytes(_email).length > 0, "Invalid name/email");

        string memory oldEmail = identities[msg.sender].email;
        if (keccak256(bytes(oldEmail)) != keccak256(bytes(_email))) {
            bytes32 newH = keccak256(bytes(_email));
            require(emailHashToAddress[newH] == address(0), "Email already used");

            if (bytes(oldEmail).length > 0) {
                emailHashToAddress[keccak256(bytes(oldEmail))] = address(0);
            }
            emailHashToAddress[newH] = msg.sender;
            identities[msg.sender].email = _email;
        }
        identities[msg.sender].name = _name;

        emit IdentityUpdated(msg.sender, _name, _email);
    }

    function deregisterIdentity() external onlyRegistered(msg.sender) whenNotPaused {
        bytes32 h = keccak256(bytes(identities[msg.sender].email));
        if (emailHashToAddress[h] != address(0)) {
            emailHashToAddress[h] = address(0);
        }
        identities[msg.sender].isRegistered = false;
        totalUsers -= 1;
        emit IdentityDeregistered(msg.sender);
    }

    function getIdentityByEmail(string calldata _email) external view returns (address) {
        if (bytes(_email).length == 0) return address(0);
        return emailHashToAddress[keccak256(bytes(_email))];
    }

    // ----------------------------
    // ISSUER ADMIN
    // ----------------------------
    function updateVerifiedIssuer(address _issuer, bool _status) external onlyOwner whenNotPaused {
        require(_issuer != address(0), "Zero address");
        require(verifiedIssuers[_issuer] != _status, "No change");
        verifiedIssuers[_issuer] = _status;
        emit IssuerStatusUpdated(_issuer, _status);
    }

    function transferOwnership(address _newOwner) external onlyOwner whenNotPaused {
        require(_newOwner != address(0), "Zero address");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }

    function renounceOwnership() external onlyOwner whenNotPaused {
        emit OwnershipTransferred(owner, address(0));
        owner = address(0);
    }

    // ----------------------------
    // PAUSE / EMERGENCY
    // ----------------------------
    function pause() external onlyOwner {
        require(!paused, "Already paused");
        paused = true;
        emit Paused(msg.sender);
    }

    function unpause() external onlyOwner {
        require(paused, "Not paused");
        paused = false;
        emit Unpaused(msg.sender);
    }

    // ----------------------------
    // CREDENTIAL LIFECYCLE
    // ----------------------------
    function issueCredential(address _subject, string calldata _title, string calldata _description)
        external onlyVerifiedIssuer onlyRegistered(_subject) whenNotPaused returns (uint256)
    {
        require(_subject != address(0) && bytes(_title).length > 0, "Invalid input");

        uint256 cid = _nextCredentialId++;
        credentials[cid] = Credential({
            id: cid,
            subject: _subject,
            issuer: msg.sender,
            title: _title,
            description: _description,
            timestamp: block.timestamp,
            state: CredentialState.Issued
        });

        userCredentialIds[_subject].push(cid);
        issuerCredentialIds[msg.sender].push(cid);

        emit CredentialIssued(cid, _subject, msg.sender, _title);
        return cid;
    }

    function issueAndVerify(address _subject, string calldata _title, string calldata _description)
        external onlyVerifiedIssuer onlyRegistered(_subject) whenNotPaused returns (uint256)
    {
        uint256 cid = issueCredential(_subject, _title, _description);
        credentials[cid].state = CredentialState.Verified;
        emit CredentialVerified(cid, msg.sender);
        return cid;
    }

    function verifyCredential(uint256 _credentialId) external onlyVerifiedIssuer credentialExists(_credentialId) whenNotPaused {
        Credential storage cred = credentials[_credentialId];
        require(cred.state == CredentialState.Issued, "Not in issued state");
        cred.state = CredentialState.Verified;
        emit CredentialVerified(_credentialId, msg.sender);
    }

    function revokeCredential(uint256 _credentialId) external credentialExists(_credentialId) whenNotPaused {
        Credential storage cred = credentials[_credentialId];
        require(cred.state != CredentialState.Revoked, "Already revoked");
        require(msg.sender == cred.issuer || msg.sender == owner, "Not authorized");
        cred.state = CredentialState.Revoked;
        emit CredentialRevoked(_credentialId, msg.sender);
    }

    function updateCredentialMetadata(uint256 _credentialId, string calldata _newTitle, string calldata _newDescription)
        external credentialExists(_credentialId) whenNotPaused
    {
        require(bytes(_newTitle).length > 0, "Empty title");
        Credential storage cred = credentials[_credentialId];
        require(msg.sender == cred.issuer, "Only issuer can update");
        require(cred.state != CredentialState.Revoked, "Cannot update revoked credential");

        cred.title = _newTitle;
        cred.description = _newDescription;
        emit CredentialUpdated(_credentialId, _newTitle, _newDescription, msg.sender);
    }

    // ----------------------------
    // VIEW / GETTERS
    // ----------------------------
    function getCredential(uint256 _credentialId)
        external view credentialExists(_credentialId)
        returns (Credential memory)
    {
        return credentials[_credentialId];
    }

    function totalCredentials() external view returns (uint256) {
        return _nextCredentialId - 1;
    }

    function getUserCredentials(address _user) external view returns (uint256[] memory) {
        return userCredentialIds[_user];
    }

    function getIssuerCredentials(address _issuer) external view returns (uint256[] memory) {
        return issuerCredentialIds[_issuer];
    }

    function getIdentity(address _user) external view returns (Identity memory) {
        return identities[_user];
    }

    function isVerifiedIssuer(address _addr) external view returns (bool) {
        return verifiedIssuers[_addr];
    }
}

